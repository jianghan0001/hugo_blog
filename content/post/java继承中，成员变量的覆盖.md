+++
tags = ["java"]
title = "java继承中，成员变量的覆盖"
draft = false
date = "2017-02-08T22:54:24+02:00"

+++



java继承中，成员变量的覆盖
其实Java继承中，成员变量(包括静态变量，实例变量，常量)没有覆盖(override)一说，应该叫隐藏(hidden)。override只针对方法来说的。

 

当成员变量为private时，其他类不能直接访问到，只能通过非private方法 访问，因此直接按照分析方法的思路分析，如该方法是否有覆盖，该方法是否是静态方法。

 

当成员变量为static时，即静态变量，在类加载过程中就分配了内存，因此只与访问的变量类型有关。

当成员变量为非private时(缺省，protected，public)，只与访问的变量类型有关。

当调用子类构造函数构建子类对象的时候，必然会先调用父类的构造函数，即构建一个父类对象(怎么得到这个对象？)，因此父类的成员(变量和方法)也会被构建。 如果存在同名，内存中将会同时存在父类的同名成员和子类的同名成员。由于Java的多态性只针对方法来说的，成员变量不存在多态，因此成员变量只与访问的变量类型有关，而方法的调用遵从多态的规则。

 1、首相要了解的知识是，成员变量绑定的是引用的类型，方法绑定的是对象的类型，

2、在继承中子类可以重写父类的方法，引用指向的是父类的对象就调用父类的方法，引用指向子类的对象就调用子类重写的方法，相反，成员变量看         的是引用的类型，父类型调用父类的成员变量，子类型调用子类的成员变量。

3、简单说 方法看对象，变量看类型。属性是静态绑定在类上，方法是动态绑定到对象上 