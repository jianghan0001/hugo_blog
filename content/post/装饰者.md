+++
tags = ["设计模式"]
title = "装饰者模式"
draft = false
date = "2017-01-23T10:54:24+02:00"

+++


动态的给一个对象添加一些额外的职责，就增加功能来说，装饰模式比生成子类更为灵活。


有效的把类的核心职责和装饰功能区分开了，而且可以去除相关类中重复的装饰逻辑。

使用场景：对象由主体+许多可选的部件或者功能构成，使用继承或者接口会产生很多类，且很难扩展。例如，现在需要一个汉堡，主体是鸡腿堡，可以选择添加生菜、酱、辣椒等等许多其他的配料，这种情况下就可以使用装饰者模式。



装饰者不但与被装饰者继承自同一个接口，并且持有该接口的引用，接收实例并进行不同的装饰处理。



![](http://i.imgur.com/gd8RfDL.gif)




ConcreteComponent：让Decorator对象为自己添加功能。有时候使用ConcreteComponent的派生类提供核心功能，在这种情况就是用ConcreteComponent替代了Component的功能，而且装饰者是继承于ConcreteComponent的子类。

Component：定义ConcreteComponent和Decorator类要实现的方法，简单来说如果一个类继承于该类就具有装饰或被装饰能力。 

Decorator：具有特定装饰功能的类，用来装饰ConcreteComponent类。



##### 策略模式和装饰者模式的区别：

策略模式更倾向是N选1的模式，也即根据条件选择相应的算法，但各种算法是互斥的，比如：团体客户和个人客户的优惠政策必然是非此即彼的； 

装饰模式是在主体逻辑的基础上的附加逻辑，比如，个人客户有的属于同城客户，支持送货上门。

策略模式，已经说的很清楚， 就不多说了。

装饰模式是主题逻辑的基础上的加强。可以看看JAVA IO的设计。
就像楼上说的， 如果客户购买满5000， 不只可以享受7折优惠， 还可以送货上门。
这里有两项功能： 1） 7折优惠， 2）送货上门
如果使用策略模式， 我们势必把两项功能都写在一个策略的实现类里面。
假使现在有新的场景出现，就是老客户购买满3000， 也享受送货上门。（或者说这里面的还蕴藏一些其他的优惠，比如说返券等等）
难道我们又把这些功能添加到我们的策略里面， 这样代码就很生硬而且不容易修改。

但是使用装饰模式就不一样，装饰模式能动态的给对象增加特有的功能。 比如说IO里面可以添加Buffer的功能。 同样在我们的场景里面，我们也可以将送货上门、返券等也动态的增强， new 送货上门（new 返券（））...., 这样子就很灵活了。