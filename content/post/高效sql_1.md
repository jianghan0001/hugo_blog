+++
tags = ["sql"]
title = "高效sql_1"
draft = false
date = "2017-02-16T10:54:24+02:00"

+++




	避免使用IN 操作符 
	   用IN写出来的SQL的优点是比较容易写及清晰易懂，这比较适合现代软件开发的风格。 
	但是用IN的SQL性能总是比较低的，从ORACLE执行的步骤来分析用IN的SQL与不用IN的SQL有以下区别： 
	　ORACLE试图将其转换成多个表的连接，如果转换不成功则先执行IN里面的子查询，再查询外层的表记录，如果转换成功则直接采用多个表的连接方式查询。由此可见用IN的SQL至少多了一个转换的过程。一般的SQL都可以转换成功，但对于含有分组统计等方面的SQL就不能转换了。 
	  　推荐方案：在业务密集的SQL当中尽量不采用IN操作符。 
	NOT IN操作符 
	  　此操作是强列推荐不使用的，因为它不能应用表的索引。
	　　推荐方案：用NOT EXISTS 或（外连接+判断为空）方案代替 
	<> 操作符（不等于） 
	  　不等于操作符是永远不会用到索引的，因此对它的处理只会产生全表扫描。 
	推荐方案：用其它相同功能的操作运算代替，如 
	　　a<>0 改为 a>0 or a<0 
	　　a<>'' 改为 a>'' 
	IS NULL 或IS NOT NULL操作（判断字段是否为空） 
	　　判断字段是否为空一般是不会应用索引的，因为B树索引是不索引空值的。 
	　　推荐方案： 
	用其它相同功能的操作运算代替，如 
	　　a is not null 改为 a>0 或a>''等。 
	　　不允许字段为空，而用一个缺省值代替空值，如业扩申请中状态字段不允许为空，缺省为申请。 
	　　建立位图索引（有分区的表不能建，位图索引比较难控制，如字段值太多索引会使性能下降，多人更新操作会增加数据块锁的现象） 
	> 及 < 操作符（大于或小于操作符） 
	  　大于或小于操作符一般情况下是不用调整的，因为它有索引就会采用索引查找，但有的情况下可以对它进行优化，如一个表有100万记录，一个数值型字段A，30万记录的A=0，30万记录的A=1，39万记录的A=2，1万记录的A=3。那么执行A>2与A>=3的Ч陀泻艽蟮那鹆耍蛭狝>2时ORACLE会先找出为2的记录索引再进行比较，而A>=3时ORACLE则直接找到=3的记录索引。 
	like操作符 
	like操作符可以应用通配符查询，里面的通配符组合可能达到几乎是任意的查询，但是如果用得不好则会产生性能上的问题，如like '%5400%' 这种查询不会引用索引，而like 'X5400%'则会引用范围索引。一个实际例子：用YW_YHJBQK表中营业编号后面的户标识号可来查询营业编号 YY_BH like '%5400%' 这个条件会产生全表扫描，如果改成YY_BH like 'X5400%' OR YY_BH like 'B5400%' 则会利用YY_BH的索引进行两个范围的查询，性能肯定大大提高。 
	union操作符 
	union在进行表链接后会筛选掉重复的记录，所以在表链接后会对所产生的结果集进行排序运算，删除重复的记录再返回结果。实际大部分应用中是不会产生重复的记录，最常见的是过程表与历史表union。如： 
	select * from gc_dfys 
	union 
	select * from ls_jg_dfys 
	这个SQL在运行时先取出两个表的结果，再用排序空间进行排序删除重复的记录，最后返回结果集，如果表数据量大的话可能会导致用磁盘进行排序。 
	推荐方案：采用union ALL操作符替代union，因为union ALL操作只是简单的将两个结果合并后就返回。 
	select * from gc_dfys 
	union all 
	select * from ls_jg_dfys